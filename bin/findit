#!/bin/bash

# A wrapper script to find files in a specified directory, with a maxdepth,
# a particular filename pattern, modified within a certain time period, with
# results optionally piped to another command
#
# Examples:
#
#   findit . --pattern "*.md" --weeks 1
#   findit --pattern "*.md" --weeks 1 --pipesort "cp -av {} /tmp/stuff"
#   findit . --complex "\( -iname '*.md' -o -iname '*.txt' \)" --months 2 --depth 3
#   findit . --pattern ".*.sw[po]" --pipe "ls -gothr"
#   findit --complex "\( -iname '*.mp4' -o -iname '*.mkv' \)" --pipesort "vlc --fullscreen"
#   findit . --ipattern "*.jpg" --stamp
#   findit --pattern "node_modules" --type d
#   findit --exclude_dirs "node_modules, .git, venv, build, alembic, __pycache__, .pytest_cache" --exclude_exts "json, yml, xml, txt, md" --pipe "wc -l"

if [[ $(uname) == 'Darwin' ]]; then
    _find="gfind"
else
    _find="find"
fi

_dirname=$1
if [[ "${_dirname:0:2}" == "--" ]]; then
    _dirname="."
elif [[ -z "$_dirname" ]]; then
    _dirname="."
else
    shift 2>/dev/null
fi

if [[ ! -d "$_dirname" ]]; then
    echo "$_dirname is not a directory"
    exit 1
fi

while [[ -n "$1" ]]; do
    case "$1" in
        --depth)
            depth=$2
            shift ;;
        --type)
            _type=$2
            shift ;;
        --complex)
            complex=$2
            shift ;;
        --exclude_dirs)
            exclude_dirs=$2
            shift ;;
        --exclude_exts)
            exclude_exts=$2
            shift ;;
        --pattern)
            pattern=$2
            shift ;;
        --ipattern)
            ipattern=$2
            shift ;;
        --exts)
            exts=$2
            shift ;;
        --months)
            months=$2
            shift ;;
        --weeks)
            weeks=$2
            shift ;;
        --days)
            days=$2
            shift ;;
        --hours)
            hours=$2
            shift ;;
        --minutes)
            minutes=$2
            shift ;;
        --pipesort)
            pipesort=$2
            shift ;;
        --pipe)
            pipe=$2
            shift ;;
        --stamp)
            stamp="-printf '%TY_%Tm%Td-%Ta-%TH%TM%.2TS %p\n'"
            ;;
        --help)
            echo "Usage: findit [dir] [options]"
            echo -e "\n  Wrapper to the find command\n\nOptions:\n"
            echo "  --depth number              maxdepth to search for files"
            echo "  --type character            regular (f)ile, (d)irectory, symbolic (l)ink, (s)ocket, (b)lock special"
            echo "  --pattern string            filename pattern or exact name"
            echo "  --ipattern string           filename pattern or exact name (case insensitive)"
            echo "  --complex string            raw options passed directly to 'find'"
            echo "  --exclude_dirs string       comma-separated list of directories to exclude"
            echo "  --exclude_exts string       comma-separated list of extensionss to exclude"
            echo "  --exts string               comma-separated list of extensionss to include"
            echo "  --months number             only match files modified in a number of months"
            echo "  --weeks number              only match files modified in a number of weeks"
            echo "  --days number               only match files modified in a number of days"
            echo "  --hours number              only match files modified in a number of hours"
            echo "  --minutes number            only match files modified in a number of minutes"
            echo "  --pipe command              pipe files to a command"
            echo "  --pipesort command          pipe sorted files to a command"
            echo "  --stamp                     prepend timestamps to output"
            echo "  --help                      show this message and exit"
            echo -e '\nExamples:\n'
            echo '  findit . --pattern "*.md" --weeks 1'
            echo '  findit --pattern "*.md" --weeks 1 --pipesort "cp -av {} /tmp/stuff"'
            echo "  findit . --complex \"\( -iname '*.md' -o -iname '*.txt' \)\" --months 2 --depth 3"
            echo '  findit . --pattern ".*.sw[po]" --pipe "ls -gothr"'
            echo "  findit --complex \"\( -iname '*.mp4' -o -iname '*.mkv' \)\" --pipesort \"vlc --fullscreen\""
            echo '  findit . --ipattern "*.jpg" --stamp'
            echo '  findit --pattern "node_modules" --type d'
            echo '  findit --exclude_dirs "node_modules, .git, venv, build, alembic, __pycache__, .pytest_cache" --exclude_exts "json, yml, xml, txt, md" --pipe "wc -l"'
            exit 0
            ;;
        *)
            echo "Unknown parameter: $1" >&2
            exit 1
    esac

    if ! shift; then
        echo "Missing parameter argument" >&2
        exit 1
    fi
done

if [[ "$_type" != [fdlspbc] ]]; then
    _type=f
fi

if [[ "$depth" == [0-9]* ]]; then
    find_cmd="$_find $_dirname -maxdepth $depth -type $_type"
else
    find_cmd="$_find $_dirname -type $_type"
fi

if [[ -n "$exclude_dirs" ]]; then
    IFS=',' read -ra items <<< "$exclude_dirs"
    if [[ ${#items[@]} -eq 1 ]]; then
        exclude_part="-not -path '*/${items[0]}/*'"
    else
        exclude_part="-not \( -path '*/${items[0]}/*'"
        set -f
        for item in ${items[@]:1}; do
            exclude_part="$exclude_part -o -path '*/$item/*'"
        done
        set +f
        exclude_part="$exclude_part \)"
    fi
    find_cmd="$find_cmd $exclude_part"
fi

if [[ -n "$exclude_exts" ]]; then
    IFS=',' read -ra items <<< "$exclude_exts"
    if [[ ${#items[@]} -eq 1 ]]; then
        exclude_part="! -iname '*.${items[0]}'"
    else
        exclude_part="! \( -iname '*.${items[0]}'"
        set -f
        for item in ${items[@]:1}; do
            exclude_part="$exclude_part -o -iname '*.$item'"
        done
        set +f
        exclude_part="$exclude_part \)"
    fi
    find_cmd="$find_cmd $exclude_part"
fi

if [[ -n "$exts" ]]; then
    IFS=',' read -ra items <<< "$exts"
    if [[ ${#items[@]} -eq 1 ]]; then
        part="-iname '*.${items[0]}'"
    else
        part="\( -iname '*.${items[0]}'"
        set -f
        for item in ${items[@]:1}; do
            part="$part -o -iname '*.$item'"
        done
        set +f
        part="$part \)"
    fi
    find_cmd="$find_cmd $part"
fi

if [[ -n "$pattern" ]]; then
    find_cmd="$find_cmd -name '$pattern'"
elif [[ -n "$ipattern" ]]; then
    find_cmd="$find_cmd -iname '$ipattern'"
elif [[ -n "$complex" ]]; then
    find_cmd="$find_cmd $complex"
fi

if [[ "$minutes" == [0-9]* ]]; then
    find_cmd="$find_cmd -mmin -$minutes"
elif [[ "$hours" == [0-9]* ]]; then
    find_cmd="$find_cmd -mmin -$((60 * $hours))"
elif [[ "$days" == [0-9]* ]]; then
    find_cmd="$find_cmd -mmin -$((60 * 24 * $days))"
elif [[ "$weeks" == [0-9]* ]]; then
    find_cmd="$find_cmd -mmin -$((60 * 24 * 7 * $weeks))"
elif [[ "$months" == [0-9]* ]]; then
    find_cmd="$find_cmd -mmin -$((60 * 24 * 31 * $months))"
fi

if [[ -n "$stamp" ]]; then
    if [[ -z "$pipesort" && -z "$pipe" ]]; then
        find_cmd="$find_cmd $stamp"
    fi
fi

xargs_dash_i=
[[ -n $(echo "$pipe$pipesort" | grep "{}") ]] && xargs_dash_i="-I {}"

if [[ -n "$pipesort" ]]; then
    echo "$find_cmd -print0 | sort -z | xargs -0 $xargs_dash_i $pipesort" >&2
    eval "$find_cmd -print0 | sort -z" | xargs -0 $xargs_dash_i $pipesort
elif [[ -n "$pipe" ]]; then
    echo "$find_cmd -print0 | xargs -0 $xargs_dash_i $pipe" >&2
    eval "$find_cmd -print0" | xargs -0 $xargs_dash_i $pipe
else
    echo "$find_cmd" >&2
    eval "$find_cmd"
fi
